import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs";
import { spawn, ChildProcess } from "child_process";

let currentProcess: ChildProcess | null = null;
let statusBarItem: vscode.StatusBarItem;

export function activate(context: vscode.ExtensionContext) {
  console.log("FRAPCON extension activated");

  // Load documentation JSON
  const docsPath = path.join(context.extensionPath, "docs", "frapconDocs.json");
  const docsRaw = fs.readFileSync(docsPath, "utf-8");
  const docs: any[] = JSON.parse(docsRaw);

  // 🔍 Helper function to find variable info
  function lookupVariable(name: string) {
    return docs.find(v => v.name.toLowerCase() === name.toLowerCase());
  }

  // 🧠 Completion Provider (variables, blocks, header snippet)
  const completionProvider = vscode.languages.registerCompletionItemProvider(
    { language: "frapcon" },
    {
      provideCompletionItems(document, position) {
        try {
          const items: vscode.CompletionItem[] = [];

          // ===== VARIABLES from docs.json =====
          docs.forEach(entry => {
            const sortText = (entry.required ? "0" : "1") + (entry.name || "");
            const kind = entry.required
              ? vscode.CompletionItemKind.EnumMember
              : vscode.CompletionItemKind.Variable;

            const item = new vscode.CompletionItem(entry.name, kind);

            // Label with red dot for required
            (item as any).label = {
              label: entry.name,
              description: entry.required ? `${entry.inputBlock} 🔴` : entry.inputBlock ?? ""
            };

            item.insertText = entry.name + "=";
            item.detail = entry.required ? "Required parameter" : "Optional parameter";
            item.sortText = sortText;
            item.documentation = new vscode.MarkdownString(
              `**${entry.name}**\n\n${entry.description}\n\n` +
                `**Units:** ${entry.units}\n\n` +
                `**Required:** ${entry.required ? "Yes 🔴" : "No"}\n\n` +
                `**Default:** ${entry.default ?? "None"}\n\n` +
                `**Block:** ${entry.inputBlock}\n\n` +
                `**Category:** ${entry.category}\n\n` +
                `**Limitations:** ${entry.limitations}`
            );

            items.push(item);
          });

          // ===== BLOCKS =====
          const blocks = [
            { name: "$frpcn", required: true },
            { name: "$frpcon", required: true },
            { name: "$emfpcn", required: false },
            { name: "$frpmox", required: false }
          ];

          blocks.forEach(block => {
            const blockItem = new vscode.CompletionItem(block.name, vscode.CompletionItemKind.Class);

            (blockItem as any).label = {
              label: block.name,
              description: block.required ? "Required Block 🔴" : "Optional Block"
            };

            // Build snippet: open, required params, close
            let snippet = block.name + "\n";
            const requiredParams = docs.filter(
              v => v.inputBlock?.toLowerCase() === block.name.toLowerCase() && v.required
            );
            requiredParams.forEach(v => {
              snippet += v.name + "=${" + v.name + "}\n";
            });
            snippet += "$end\n";

            blockItem.insertText = new vscode.SnippetString(snippet);
            blockItem.detail = block.required ? "Required block" : "Optional block";
            blockItem.documentation = new vscode.MarkdownString(
              `**${block.name}** block\n\nEnds with \`$end\`\n\n` +
                (requiredParams.length
                  ? `Required parameters inside:\n- ${requiredParams.map(v => v.name).join("\n- ")}`
                  : "No required parameters.")
            );

            items.push(blockItem);
          });

          // ===== HEADER SNIPPET =====
          const headerSnippet = new vscode.CompletionItem(
            "$header",
            vscode.CompletionItemKind.File
          );
          headerSnippet.insertText = new vscode.SnippetString(
            `*=====================================================================*\n` +
            `*            FRAPCON3.4 - Steady-State Fuel Rod Analysis Code         *\n` +
            `*=====================================================================*\n` +
            `*-----------------------------Input Files-----------------------------*\n` +
            `FILE05='nullfile',\n\t\t\t\tSTATUS='UNKNOWN',\n\t\t\t\tFORM='FORMATTED',\n\t\t\t\tCARRIAGE CONTROL='NONE'\n` +
            `*-----------------------------Output Files----------------------------*\n` +
            `FILE06='\${1:case}.out',\n\t\t\t\tSTATUS='UNKNOWN',\n\t\t\t\tCARRIAGE CONTROL='LIST'\n` +
            `FILE66='\${1:case}.plot',\n\t\t\t\tSTATUS='UNKNOWN',\n\t\t\t\tFORM='FORMATTED',\n\t\t\t\tCARRIAGE CONTROL='LIST'\n` +
            `*=====================================================================*\n` +
            `/************************ Case : \${2:Name (max 72 chars)} ************************/\n` +
            `*=====================================================================*\n` +
            `\n`
          );
          headerSnippet.detail = "FRAPCON input header (file setup + case description)";
          headerSnippet.documentation = new vscode.MarkdownString(
            "Inserts the required file setup lines (`FILE05`, `FILE06`, `FILE66`), the `/*********` separator, " +
              "and a placeholder for the case description. These lines must precede all `$frpcn`, `$frpcon`, `$emfpcn`, `$frpmox` blocks."
          );
          items.push(headerSnippet);

          return items;
        } catch (err) {
          console.error("FRAPCON completion error:", err);
          return [];
        }
      }
    },
    ".", "$" // trigger chars
  );

  // 🖱️ Hover Provider
  const hoverProvider = vscode.languages.registerHoverProvider("frapcon", {
    provideHover(document, position) {
      const wordRange = document.getWordRangeAtPosition(position, /[A-Za-z0-9_\$]+/);
      if (!wordRange) return;
      const word = document.getText(wordRange);

      // Special-case FILE05/06/66
      if (word.toUpperCase() === "FILE05") {
        return new vscode.Hover(
          new vscode.MarkdownString("**FILE05**: Creates the `nullfile`, required for FRAPCON-3.3.")
        );
      }
      if (word.toUpperCase() === "FILE06") {
        return new vscode.Hover(
          new vscode.MarkdownString(
            "**FILE06**: Specifies the output file (default: `file.out`)."
          )
        );
      }
      if (word.toUpperCase() === "FILE66") {
        return new vscode.Hover(
          new vscode.MarkdownString(
            "**FILE66**: Specifies the optional plot file (default: `file.plot`). Used if NPLOT is set."
          )
        );
      }

      const entry = lookupVariable(word);
      if (entry) {
        const markdown = new vscode.MarkdownString(
          `### ${entry.name}\n\n` +
            `*${entry.description}*\n\n` +
            `**Units:** ${entry.units}\n\n` +
            `**Required:** ${entry.required ? "Yes" : "No"}\n\n` +
            `**Default:** ${entry.default ?? "None"}\n\n` +
            `**Block:** ${entry.inputBlock}\n\n` +
            `**Category:** ${entry.category}\n\n` +
            `**Limitations:** ${entry.limitations}`
        );
        markdown.isTrusted = true;
        return new vscode.Hover(markdown);
      }
    }
  });

  // ▶ Run FRAPCON Command
  const runCommand = vscode.commands.registerCommand("frapcon.run", async () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage("No active editor found to run FRAPCON.");
      return;
    }

    const document = editor.document;
    if (document.languageId !== "frapcon") {
      vscode.window.showErrorMessage("FRAPCON can only run on .inp (FRAPCON) files.");
      return;
    }

    const config = vscode.workspace.getConfiguration("frapcon");
    let executablePath: string | undefined = config.get("executablePath");

    if (!executablePath) {
      const selected = await vscode.window.showInputBox({
        placeHolder: "Enter the full path to FRAPCON executable",
        prompt: "Example: C:\\FRAPCON\\FRAPCON3_4a.exe or /usr/local/bin/frapcon",
        ignoreFocusOut: true
      });

      if (!selected) {
        vscode.window.showErrorMessage("FRAPCON executable path is required.");
        return;
      }

      executablePath = selected;
      await config.update("executablePath", executablePath, vscode.ConfigurationTarget.Global);
    }

    const filePath = document.fileName;
    const inputFileName = path.basename(filePath);
    if (!fs.existsSync(executablePath)) {
      vscode.window.showErrorMessage(`FRAPCON executable not found at: ${executablePath}`);
      return;
    }

    const outputChannel = vscode.window.createOutputChannel("FRAPCON");
    outputChannel.show(true);
    outputChannel.appendLine(`FRAPCON Executable: ${executablePath}`);
    outputChannel.appendLine(`Working Directory : ${filePath}`);
    outputChannel.appendLine(`Input File        : ${inputFileName}\n`);
    outputChannel.appendLine(`------------------------------------\n`);

    try {
      if (currentProcess) {
        currentProcess.kill();
        currentProcess = null;
      }

      currentProcess = spawn(executablePath, [filePath], {
        cwd: path.dirname(filePath),
        shell: true
      });

      if (currentProcess.stdout) {
        currentProcess.stdout.on("data", data => {
          outputChannel.append(data.toString());
        });
      }

      if (currentProcess.stderr) {
        currentProcess.stderr.on("data", data => {
          outputChannel.append(`ERROR: ${data.toString()}`);
        });
      }

      currentProcess.on("close", code => {
        currentProcess = null;
        updateStatusBar();
      });

      updateStatusBar();
    } catch (err: any) {
      vscode.window.showErrorMessage(`Failed to run FRAPCON: ${err.message}`);
    }
  });

  // ⏹ Terminate FRAPCON Command
  const terminateCommand = vscode.commands.registerCommand("frapcon.terminate", () => {
    if (currentProcess) {
      currentProcess.kill();
      vscode.window.showInformationMessage("FRAPCON terminated.");
      currentProcess = null;
    } else {
      vscode.window.showWarningMessage("FRAPCON is not running.");
    }
    updateStatusBar();
  });

  // 📄 Generate Input Template Command
  const templateCommand = vscode.commands.registerCommand("frapcon.generateTemplate", async () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage("Open an editor to insert template.");
      return;
    }

    const snippet = new vscode.SnippetString(
      `FILE05='nullfile', STATUS='UNKNOWN', FORM='FORMATTED', CARRIAGE CONTROL='NONE'\n` +
        `FILE06='\${1:case}.out', STATUS='UNKNOWN', CARRIAGE CONTROL='LIST'\n` +
        `FILE66='\${1:case}.plot', STATUS='UNKNOWN', FORM='FORMATTED', CARRIAGE CONTROL='LIST'\n` +
        `/***********************************************************************\n` +
        `\${2:Case description goes here (max 72 chars)}\n\n` +
        `$frpcn\n$end\n\n` +
        `$frpcon\n$end\n\n` +
        `$emfpcn\n$end\n\n` +
        `$frpmox\n$end\n`
    );
    editor.insertSnippet(snippet);
  });

  // ⚡ Status Bar Item
  statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
  statusBarItem.command = "frapcon.run";
  context.subscriptions.push(statusBarItem);
  updateStatusBar();
  statusBarItem.show();

  // 📦 Register providers and commands
  context.subscriptions.push(
    completionProvider,
    hoverProvider,
    runCommand,
    terminateCommand,
    templateCommand
  );
}

export function deactivate() {
  if (currentProcess) {
    currentProcess.kill();
    currentProcess = null;
  }
}

// 🔄 Update status bar text & command
function updateStatusBar() {
  if (currentProcess) {
    statusBarItem.text = "$(debug-stop) Terminate FRAPCON";
    statusBarItem.tooltip = "Click to terminate FRAPCON";
    statusBarItem.command = "frapcon.terminate";
    vscode.commands.executeCommand("setContext", "frapconRunning", true);
  } else {
    statusBarItem.text = "$(play) Run FRAPCON";
    statusBarItem.tooltip = "Click to run FRAPCON on the active file";
    statusBarItem.command = "frapcon.run";
    vscode.commands.executeCommand("setContext", "frapconRunning", false);
  }
}
